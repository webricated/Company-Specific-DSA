## âœ… Problem: 4. Road Network Breakdown

### ðŸ” **Problem Description**

The cityâ€™s road network is represented as an undirected graph with `n` intersections (nodes) and `m` roads (edges). Certain roads are **critical** â€” if any one of them is removed, the cityâ€™s network will become disconnected (i.e., at least one pair of intersections will no longer be reachable from one another).

Your task is to identify and list all such **critical roads (bridges)** in the network.

---

### ðŸ“¥ Input Format

```
n m
u1 v1
u2 v2
...
um vm
```

* First line: two integers `n` (number of nodes), `m` (number of edges).
* Next `m` lines: each contains two integers `ui` and `vi` representing a bidirectional road between intersection `ui` and `vi`.

> **Note:** Nodes are numbered from 0 to n-1.

---

### ðŸ“¤ Output Format

Print all critical roads, one per line, in the form:

```
u v
```

Where `(u, v)` is a bridge. The order of edges or nodes in each pair does not matter. If there are no bridges, print nothing.

---

### ðŸ“Œ Constraints

* `1 â‰¤ n â‰¤ 10^5`
* `0 â‰¤ m â‰¤ 10^5`
* `0 â‰¤ ui, vi < n`
* There are no parallel edges or self-loops.

---

### ðŸ§ª Sample Test Case 1

**Input**

```
5 5
0 1
1 2
2 0
1 3
3 4
```

**Output**

```
3 4
1 3
```

> Removing either (3-4) or (1-3) disconnects the network.

---

### ðŸ§ª Sample Test Case 2

**Input**

```
4 3
0 1
1 2
2 3
```

**Output**

```
2 3
1 2
0 1
```

> This is a linear chain; every edge is a bridge.

---

## ðŸ§  Approach

We use **Tarjanâ€™s Algorithm** to find **bridges in a graph** using DFS. The core idea is to track:

* `disc[u]`: Discovery time of a node `u` in DFS
* `low[u]`: The lowest discovery time reachable from the subtree rooted at `u`

For each node `u`, if you explore a child `v` such that `low[v] > disc[u]`, then the edge `(u, v)` is a **bridge**.

---

## âœ… Code with Line-by-Line Explanation

```java
import java.util.*;

public class CriticalRoadsFinder {
    static int time = 0; // global timer for discovery times

    // Main function to find all bridges
    public static List<List<Integer>> findBridges(int n, List<List<Integer>> edges) {
        // Step 1: Build adjacency list
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());

        for (List<Integer> edge : edges) {
            int u = edge.get(0), v = edge.get(1);
            adj.get(u).add(v);
            adj.get(v).add(u); // since undirected
        }

        // Step 2: Arrays to track discovery and low values
        int[] disc = new int[n]; // Discovery times
        int[] low = new int[n];  // Lowest reachable discovery time
        boolean[] visited = new boolean[n]; // visited flags

        List<List<Integer>> bridges = new ArrayList<>();

        // Step 3: Call DFS from every unvisited node
        for (int i = 0; i < n; i++) {
            if (!visited[i])
                dfs(i, -1, disc, low, visited, adj, bridges);
        }

        return bridges;
    }

    // DFS Function to detect bridges
    private static void dfs(int u, int parent, int[] disc, int[] low, boolean[] visited,
                            List<List<Integer>> adj, List<List<Integer>> bridges) {
        visited[u] = true;
        disc[u] = low[u] = ++time; // Set discovery and low time

        for (int v : adj.get(u)) {
            if (v == parent) continue; // Don't go back to parent

            if (!visited[v]) {
                dfs(v, u, disc, low, visited, adj, bridges); // DFS to neighbor

                low[u] = Math.min(low[u], low[v]); // Update low of current

                // Condition for a bridge
                if (low[v] > disc[u]) {
                    bridges.add(Arrays.asList(u, v)); // Save the bridge
                }
            } else {
                low[u] = Math.min(low[u], disc[v]); // Update low with back edge
            }
        }
    }

    // Sample usage
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        List<List<Integer>> edges = new ArrayList<>();

        for (int i = 0; i < m; i++) {
            int u = sc.nextInt(), v = sc.nextInt();
            edges.add(Arrays.asList(u, v));
        }

        List<List<Integer>> bridges = findBridges(n, edges);
        for (List<Integer> bridge : bridges) {
            System.out.println(bridge.get(0) + " " + bridge.get(1));
        }
    }
}
```

---

## ðŸ§® Time and Space Complexity

| Metric          | Complexity |
| --------------- | ---------- |
| Time            | O(V + E)   |
| Space           | O(V + E)   |
| DFS Stack Depth | O(V)       |



---

---

### âœ… Full Java Code with Line-by-Line Explanation

```java
import java.util.*;
```

> Imports Java utility classes like `List`, `ArrayList`, `Scanner`, `Arrays`.

---

```java
public class CriticalRoadsFinder {
```

> Start of the class that contains the bridge-finding logic.

---

```java
    static int time = 0; // global timer for discovery times
```

> A global variable `time` that increments with each DFS call to assign **discovery times** to nodes.

---

```java
    public static List<List<Integer>> findBridges(int n, List<List<Integer>> edges) {
```

> This function will return all the bridges (critical roads) from a graph of `n` nodes and given edge list.

---

```java
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());
```

> Initialize an **adjacency list** `adj` of size `n` to represent the graph. Each index contains a list of connected nodes.

---

```java
        for (List<Integer> edge : edges) {
            int u = edge.get(0), v = edge.get(1);
            adj.get(u).add(v);
            adj.get(v).add(u); // since undirected
        }
```

> Loop through the given list of edges and populate the adjacency list.
> Since the graph is undirected, add `v` to `u`â€™s list and vice versa.

---

```java
        int[] disc = new int[n]; // Discovery times
        int[] low = new int[n];  // Lowest reachable discovery time
        boolean[] visited = new boolean[n]; // visited flags
```

> Arrays for:

* `disc[i]`: Time when node `i` is first visited.
* `low[i]`: The lowest discovery time reachable from node `i`.
* `visited[i]`: Boolean flag to check if node `i` has been visited.

---

```java
        List<List<Integer>> bridges = new ArrayList<>();
```

> This list will store all the bridges as pairs of nodes.

---

```java
        for (int i = 0; i < n; i++) {
            if (!visited[i])
                dfs(i, -1, disc, low, visited, adj, bridges);
        }
```

> Perform DFS traversal from every unvisited node.
> `-1` is passed as the parent of the root node of the DFS tree.

---

```java
        return bridges;
    }
```

> Return the list of bridges after DFS traversal is complete.

---

### ðŸ”„ DFS Function

```java
    private static void dfs(int u, int parent, int[] disc, int[] low, boolean[] visited,
                            List<List<Integer>> adj, List<List<Integer>> bridges) {
```

> Recursive DFS function to traverse the graph and compute `disc[]` and `low[]` values.

---

```java
        visited[u] = true;
        disc[u] = low[u] = ++time; // Set discovery and low time
```

> Mark `u` as visited.
> Assign `disc[u]` and `low[u]` with the current time (DFS step counter).
> `low[u]` is initialized to `disc[u]` for now.

---

```java
        for (int v : adj.get(u)) {
```

> For each neighbor `v` of node `u`, we analyze the edge `(u, v)`.

---

```java
            if (v == parent) continue; // Don't go back to parent
```

> Skip the edge that leads back to the parent in DFS (to avoid infinite cycle).

---

```java
            if (!visited[v]) {
```

> If the neighbor `v` is not visited yet, do DFS on it.

---

```java
                dfs(v, u, disc, low, visited, adj, bridges); // DFS to neighbor
```

> Recursively visit neighbor `v`, passing current node `u` as its parent.

---

```java
                low[u] = Math.min(low[u], low[v]); // Update low of current
```

> After returning from DFS call on `v`, update the `low[u]` value based on `low[v]`.
> This helps in checking if `v` can reach an ancestor of `u`.

---

```java
                if (low[v] > disc[u]) {
                    bridges.add(Arrays.asList(u, v)); // Save the bridge
                }
```

> If `low[v] > disc[u]`, then `v` cannot reach back to `u` or any ancestor â†’ the edge `(u, v)` is a **bridge**.

---

```java
            } else {
                low[u] = Math.min(low[u], disc[v]); // Update low with back edge
            }
```

> If `v` is already visited and is not parent, itâ€™s a **back edge**, so update `low[u]` using `disc[v]`.

---

### ðŸ§ª Main Method â€“ Input Reading and Output

```java
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        List<List<Integer>> edges = new ArrayList<>();
```

> Take input for number of nodes `n` and edges `m`, then initialize edge list.

---

```java
        for (int i = 0; i < m; i++) {
            int u = sc.nextInt(), v = sc.nextInt();
            edges.add(Arrays.asList(u, v));
        }
```

> Read all `m` edges from input.

---

```java
        List<List<Integer>> bridges = findBridges(n, edges);
        for (List<Integer> bridge : bridges) {
            System.out.println(bridge.get(0) + " " + bridge.get(1));
        }
    }
}
```

> Call `findBridges`, and print each bridge (critical road) one per line.

---

### âœ… Output Example

**Input**

```
5 5
0 1
1 2
2 0
1 3
3 4
```

**Output**

```
3 4
1 3
```

---

